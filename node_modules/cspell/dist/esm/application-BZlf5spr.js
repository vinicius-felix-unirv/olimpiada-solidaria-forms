import { createRequire } from "node:module";
import chalk, { Chalk } from "chalk";
import { isAsyncIterable, opFilter, opMap, opTap, operators, pipeAsync, pipeAsync as asyncPipe, toAsyncIterable, toAsyncIterable as mergeAsyncIterables } from "@cspell/cspell-pipe";
import * as cspell from "cspell-lib";
import { ENV_CSPELL_GLOB_ROOT, IncludeExcludeFlag, SuggestionError, Text, checkTextDocument, combineTextAndLanguageSettings, createPerfTimer, extractDependencies, extractImportErrors, fileToDocument, getDefaultSettings, getDictionary, getGlobalSettingsAsync, getSystemFeatureFlags, isBinaryFile, isSpellingDictionaryLoadError, mergeSettings, setLogger, shouldCheckDocument, spellCheckDocument, suggestionsForWords, traceWordsAsync } from "cspell-lib";
import assert from "node:assert";
import { format, formatWithOptions } from "node:util";
import { isUrlLike, toFileDirURL, toFilePathOrHref, toFileURL, urlRelative } from "@cspell/url";
import { makeTemplate } from "chalk-template";
import fs, { stat } from "node:fs/promises";
import { MutableCSpellConfigFile, createReaderWriter, cspellConfigFileSchema, isCfgArrayNode } from "cspell-config-lib";
import { promises } from "node:fs";
import { fileURLToPath } from "node:url";
import * as path$1 from "node:path";
import path, { isAbsolute, posix, relative, resolve, sep } from "node:path";
import { opMap as opMap$1, pipe } from "@cspell/cspell-pipe/sync";
import { IssueType, MessageTypes, unknownWordsChoices } from "@cspell/cspell-types";
import { _debug } from "cspell-dictionary";
import { GitIgnore, findRepoRoot } from "cspell-gitignore";
import { GlobMatcher, fileOrGlobToGlob, workaroundPicomatchBug } from "cspell-glob";
import crypto from "node:crypto";
import streamConsumers from "node:stream/consumers";
import { readFileText, toURL } from "cspell-io";
import { glob } from "tinyglobby";
import * as readline from "node:readline";
import { parse, stringify } from "flatted";
import { dynamicImport } from "@cspell/dynamic-import";

//#region src/console.ts
var ImplChannel = class {
	constructor(stream) {
		this.stream = stream;
	}
	write = (msg) => this.stream.write(msg);
	writeLine = (msg) => this.write(msg + "\n");
	clearLine = (dir, callback) => this.stream.clearLine?.(dir, callback) ?? false;
	printLine = (...params) => this.writeLine(params.length && formatWithOptions({ colors: this.stream.hasColors?.() }, ...params) || "");
	getColorLevel = () => getColorLevel(this.stream);
};
var Console = class {
	stderrChannel;
	stdoutChannel;
	constructor(stdout = process.stdout, stderr = process.stderr) {
		this.stdout = stdout;
		this.stderr = stderr;
		this.stderrChannel = new ImplChannel(this.stderr);
		this.stdoutChannel = new ImplChannel(this.stdout);
	}
	log = (...p) => this.stdoutChannel.printLine(...p);
	error = (...p) => this.stderrChannel.printLine(...p);
	info = this.log;
	warn = this.error;
};
const console = new Console();
function getColorLevel(stream) {
	const depth = stream.getColorDepth?.() || 0;
	switch (depth) {
		case 1: return 1;
		case 4: return 2;
		case 24: return 3;
		default: return 0;
	}
}

//#endregion
//#region src/util/errors.ts
var CheckFailed = class extends Error {
	constructor(message, exitCode = 1) {
		super(message);
		this.exitCode = exitCode;
	}
};
var ApplicationError = class extends Error {
	constructor(message, exitCode = 1, cause) {
		super(message);
		this.exitCode = exitCode;
		this.cause = cause;
	}
};
var IOError = class extends ApplicationError {
	constructor(message, cause) {
		super(message, void 0, cause);
		this.cause = cause;
	}
	get code() {
		return this.cause.code;
	}
	isNotFound() {
		return this.cause.code === "ENOENT";
	}
};
function toError(e) {
	if (isError(e)) return e;
	if (isErrorLike(e)) {
		const ex = new Error(e.message, { cause: e });
		if (e.code !== void 0) ex.code = e.code;
		return ex;
	}
	const message = format(e);
	return new Error(message);
}
function isError(e) {
	return e instanceof Error;
}
function isErrorLike(e) {
	if (e instanceof Error) return true;
	if (!e || typeof e !== "object") return false;
	const ex = e;
	return typeof ex.message === "string";
}
function toApplicationError(e, message) {
	if (e instanceof ApplicationError && !message) return e;
	const err = toError(e);
	return new ApplicationError(message ?? err.message, void 0, err);
}

//#endregion
//#region src/util/util.ts
const uniqueFn = uniqueFilterFnGenerator;
function uniqueFilterFnGenerator(extractFn) {
	const values = /* @__PURE__ */ new Set();
	const extractor = extractFn || ((a) => a);
	return (v) => {
		const vv = extractor(v);
		const ret = !values.has(vv);
		values.add(vv);
		return ret;
	};
}
/**
* Removed all properties with a value of `undefined` from the object.
* @param src - the object to clean.
* @returns the same object with all properties with a value of `undefined` removed.
*/
function clean(src) {
	const r = src;
	for (const key of Object.keys(r)) if (r[key] === void 0) delete r[key];
	return r;
}

//#endregion
//#region src/cli-reporter.ts
const templateIssue = `{green $filename}:{yellow $row:$col} - $message ({red $text}) $quickFix`;
const templateIssueNoFix = `{green $filename}:{yellow $row:$col} - $message ({red $text})`;
const templateIssueWithSuggestions = `{green $filename}:{yellow $row:$col} - $message ({red $text}) Suggestions: {yellow [$suggestions]}`;
const templateIssueWithContext = `{green $filename}:{yellow $row:$col} $padRowCol- $message ({red $text})$padContext -- {gray $contextLeft}{red {underline $text}}{gray $contextRight}`;
const templateIssueWithContextWithSuggestions = `{green $filename}:{yellow $row:$col} $padRowCol- $message ({red $text})$padContext -- {gray $contextLeft}{red {underline $text}}{gray $contextRight}\n\t Suggestions: {yellow [$suggestions]}`;
const templateIssueLegacy = `{green $filename}[$row, $col]: $message: {red $text}`;
const templateIssueWordsOnly = "$text";
assert(true);
/**
*
* @param template - The template to use for the issue.
* @param uniqueIssues - If true, only unique issues will be reported.
* @param reportedIssuesCollection - optional collection to store reported issues.
* @returns issueEmitter function
*/
function genIssueEmitter(stdIO, errIO, template, uniqueIssues, reportedIssuesCollection) {
	const uniqueFilter = uniqueIssues ? uniqueFilterFnGenerator((issue) => issue.text) : () => true;
	const defaultWidth = 10;
	let maxWidth = defaultWidth;
	let uri;
	return function issueEmitter(issue) {
		if (!uniqueFilter(issue)) return;
		if (uri !== issue.uri) {
			maxWidth = defaultWidth;
			uri = issue.uri;
		}
		maxWidth = Math.max(maxWidth * .999, issue.text.length, 10);
		const issueText = formatIssue(stdIO, template, issue, Math.ceil(maxWidth));
		reportedIssuesCollection?.push(formatIssue(errIO, template, issue, Math.ceil(maxWidth)));
		stdIO.writeLine(issueText);
	};
}
function nullEmitter() {}
function relativeUriFilename(uri, rootURL) {
	const url = toFileURL(uri);
	const rel = urlRelative(rootURL, url);
	if (rel.startsWith("..")) return toFilePathOrHref(url);
	return rel;
}
function reportProgress(io, p, cwdURL, options) {
	if (p.type === "ProgressFileComplete") return reportProgressFileComplete(io, p, cwdURL, options);
	if (p.type === "ProgressFileBegin") return reportProgressFileBegin(io, p, cwdURL);
}
function determineFilename(io, p, cwd) {
	const fc = "" + p.fileCount;
	const fn = (" ".repeat(fc.length) + p.fileNum).slice(-fc.length);
	const idx = fn + "/" + fc;
	const filename = io.chalk.gray(relativeUriFilename(p.filename, cwd));
	return {
		idx,
		filename
	};
}
function reportProgressFileBegin(io, p, cwdURL) {
	const { idx, filename } = determineFilename(io, p, cwdURL);
	if (io.getColorLevel() > 0) {
		io.clearLine?.(0);
		io.write(`${idx} ${filename}\r`);
	}
}
function reportProgressFileComplete(io, p, cwd, options) {
	const { idx, filename } = determineFilename(io, p, cwd);
	const { verbose, debug } = options;
	const time = reportTime(io, p.elapsedTimeMs, !!p.cached);
	const skipped = p.processed === false ? " skipped" : "";
	const hasErrors = p.numErrors ? io.chalk.red` X` : "";
	const newLine = skipped && (verbose || debug) || hasErrors || isSlow(p.elapsedTimeMs) || io.getColorLevel() < 1 ? "\n" : "";
	const msg = `${idx} ${filename} ${time}${skipped}${hasErrors}${newLine || "\r"}`;
	io.write(msg);
}
function reportTime(io, elapsedTimeMs, cached) {
	if (cached) return io.chalk.green("cached");
	if (elapsedTimeMs === void 0) return "-";
	const slow = isSlow(elapsedTimeMs);
	const color = !slow ? io.chalk.white : slow === 1 ? io.chalk.yellow : io.chalk.redBright;
	return color(elapsedTimeMs.toFixed(2) + "ms");
}
function isSlow(elapsedTmeMs) {
	if (!elapsedTmeMs || elapsedTmeMs < 1e3) return 0;
	if (elapsedTmeMs < 2e3) return 1;
	return 2;
}
function getReporter(options, config) {
	const perfStats = {
		filesProcessed: 0,
		filesSkipped: 0,
		filesCached: 0,
		elapsedTimeMs: 0,
		perf: Object.create(null)
	};
	const noColor = options.color === false;
	const forceColor = options.color === true;
	const uniqueIssues = config?.unique || false;
	const defaultIssueTemplate = options.wordsOnly ? templateIssueWordsOnly : options.legacy ? templateIssueLegacy : options.showContext ? options.showSuggestions ? templateIssueWithContextWithSuggestions : templateIssueWithContext : options.showSuggestions ? templateIssueWithSuggestions : options.showSuggestions === false ? templateIssueNoFix : templateIssue;
	const { fileGlobs, silent, summary, issues, progress: showProgress, verbose, debug } = options;
	const issueTemplate = config?.issueTemplate || defaultIssueTemplate;
	assertCheckTemplate(issueTemplate);
	const console$1 = config?.console || console;
	const colorLevel = noColor ? 0 : forceColor ? 2 : console$1.stdoutChannel.getColorLevel();
	const stdio = {
		...console$1.stdoutChannel,
		chalk: new Chalk({ level: colorLevel })
	};
	const stderr = {
		...console$1.stderrChannel,
		chalk: new Chalk({ level: colorLevel })
	};
	const consoleError = (msg) => stderr.writeLine(msg);
	function createInfoLog(wrap) {
		return (msg) => console$1.info(wrap(msg));
	}
	const emitters = {
		Debug: !silent && debug ? createInfoLog(stdio.chalk.cyan) : nullEmitter,
		Info: !silent && verbose ? createInfoLog(stdio.chalk.yellow) : nullEmitter,
		Warning: createInfoLog(stdio.chalk.yellow)
	};
	function infoEmitter(message, msgType) {
		emitters[msgType]?.(message);
	}
	const rootURL = toFileDirURL(options.root || process.cwd());
	function relativeIssue(fn) {
		const fnFilename = options.relative ? (uri) => relativeUriFilename(uri, rootURL) : (uri) => toFilePathOrHref(toFileURL(uri, rootURL));
		return (i) => {
			const fullFilename = i.uri ? toFilePathOrHref(toFileURL(i.uri, rootURL)) : "";
			const filename = i.uri ? fnFilename(i.uri) : "";
			const r = {
				...i,
				filename,
				fullFilename
			};
			fn(r);
		};
	}
	const issuesCollection = void 0;
	const errorCollection = [];
	function errorEmitter(message, error) {
		if (isSpellingDictionaryLoadError(error)) error = error.cause;
		const errorText = formatWithOptions({ colors: stderr.stream.hasColors?.() }, stderr.chalk.red(message), debug ? error : error.toString());
		errorCollection?.push(errorText);
		consoleError(errorText);
	}
	const resultEmitter = (result) => {
		if (!fileGlobs.length && !result.files) return;
		const { files, issues: issues$1, cachedFiles, filesWithIssues, errors } = result;
		const numFilesWithIssues = filesWithIssues.size;
		if (stderr.getColorLevel() > 0) {
			stderr.write("\r");
			stderr.clearLine(0);
		}
		if (issuesCollection?.length || errorCollection?.length) consoleError("-------------------------------------------");
		if (issuesCollection?.length) {
			consoleError("Issues found:");
			issuesCollection.forEach((issue) => consoleError(issue));
		}
		const cachedFilesText = cachedFiles ? ` (${cachedFiles} from cache)` : "";
		const withErrorsText = errors ? ` with ${errors} error${errors === 1 ? "" : "s"}` : "";
		const numFilesWidthIssuesText = numFilesWithIssues === 1 ? "1 file" : `${numFilesWithIssues} files`;
		const summaryMessage = `CSpell\u003A Files checked: ${files}${cachedFilesText}, Issues found: ${issues$1} in ${numFilesWidthIssuesText}${withErrorsText}.`;
		consoleError(summaryMessage);
		if (errorCollection?.length && issues$1 > 5) {
			consoleError("-------------------------------------------");
			consoleError("Errors:");
			errorCollection.forEach((error) => consoleError(error));
		}
		if (options.showPerfSummary) {
			consoleError("-------------------------------------------");
			consoleError("Performance Summary:");
			consoleError(`  Files Processed: ${perfStats.filesProcessed.toString().padStart(6)}`);
			consoleError(`  Files Skipped  : ${perfStats.filesSkipped.toString().padStart(6)}`);
			consoleError(`  Files Cached   : ${perfStats.filesCached.toString().padStart(6)}`);
			consoleError(`  Processing Time: ${perfStats.elapsedTimeMs.toFixed(2).padStart(9)}ms`);
			consoleError("Stats:");
			const stats = Object.entries(perfStats.perf).filter((p) => !!p[1]).map(([key, value]) => [key, value.toFixed(2)]);
			const padName = Math.max(...stats.map((s) => s[0].length));
			const padValue = Math.max(...stats.map((s) => s[1].length));
			stats.sort((a, b) => a[0].localeCompare(b[0]));
			for (const [key, value] of stats) value && consoleError(`  ${key.padEnd(padName)}: ${value.padStart(padValue)}ms`);
		}
	};
	function collectPerfStats(p) {
		if (p.cached) {
			perfStats.filesCached++;
			return;
		}
		perfStats.filesProcessed += p.processed ? 1 : 0;
		perfStats.filesSkipped += !p.processed ? 1 : 0;
		perfStats.elapsedTimeMs += p.elapsedTimeMs || 0;
		if (!p.perf) return;
		for (const [key, value] of Object.entries(p.perf)) if (typeof value === "number") perfStats.perf[key] = (perfStats.perf[key] || 0) + value;
	}
	function progress(p) {
		if (!silent && showProgress) reportProgress(stderr, p, rootURL, options);
		if (p.type === "ProgressFileComplete") collectPerfStats(p);
	}
	return {
		issue: relativeIssue(silent || !issues ? nullEmitter : genIssueEmitter(stdio, stderr, issueTemplate, uniqueIssues, issuesCollection)),
		error: silent ? nullEmitter : errorEmitter,
		info: infoEmitter,
		debug: emitters.Debug,
		progress,
		result: !silent && summary ? resultEmitter : nullEmitter,
		features: void 0
	};
}
function formatIssue(io, templateStr, issue, maxIssueTextWidth) {
	function clean$1(t$1) {
		return t$1.replace(/\s+/, " ");
	}
	const { uri = "", filename, row, col, text, context = issue.line, offset } = issue;
	const contextLeft = clean$1(context.text.slice(0, offset - context.offset));
	const contextRight = clean$1(context.text.slice(offset + text.length - context.offset));
	const contextFull = clean$1(context.text);
	const padContext = " ".repeat(Math.max(maxIssueTextWidth - text.length, 0));
	const rowText = row.toString();
	const colText = col.toString();
	const padRowCol = " ".repeat(Math.max(1, 8 - (rowText.length + colText.length)));
	const suggestions$1 = formatSuggestions(io, issue);
	const msg = issue.message || (issue.isFlagged ? "Forbidden word" : "Unknown word");
	const messageColored = issue.isFlagged ? `{yellow ${msg}}` : msg;
	const substitutions = {
		$col: colText,
		$contextFull: contextFull,
		$contextLeft: contextLeft,
		$contextRight: contextRight,
		$filename: filename,
		$padContext: padContext,
		$padRowCol: padRowCol,
		$row: rowText,
		$suggestions: suggestions$1,
		$text: text,
		$uri: uri,
		$quickFix: formatQuickFix(io, issue),
		$message: msg,
		$messageColored: messageColored
	};
	const t = templateStr.replaceAll("$messageColored", messageColored);
	const chalkTemplate = makeTemplate(io.chalk);
	return substitute(chalkTemplate(t), substitutions).trimEnd();
}
function formatSuggestions(io, issue) {
	if (issue.suggestionsEx) return issue.suggestionsEx.map((sug) => sug.isPreferred ? io.chalk.italic(io.chalk.bold(sug.wordAdjustedToMatchCase || sug.word)) + "*" : sug.wordAdjustedToMatchCase || sug.word).join(", ");
	if (issue.suggestions) return issue.suggestions.join(", ");
	return "";
}
function formatQuickFix(io, issue) {
	if (!issue.suggestionsEx?.length) return "";
	const preferred = issue.suggestionsEx.filter((sug) => sug.isPreferred).map((sug) => sug.wordAdjustedToMatchCase || sug.word);
	if (!preferred.length) return "";
	const fixes = preferred.map((w) => io.chalk.italic(io.chalk.yellow(w)));
	return `fix: (${fixes.join(", ")})`;
}
function substitute(text, substitutions) {
	const subs = [];
	for (const [match, replaceWith] of Object.entries(substitutions)) {
		const len = match.length;
		for (let i$1 = text.indexOf(match); i$1 >= 0; i$1 = text.indexOf(match, i$1)) {
			const end = i$1 + len;
			const reg = /\b/y;
			reg.lastIndex = end;
			if (reg.test(text)) subs.push([
				i$1,
				end,
				replaceWith
			]);
			i$1 = end;
		}
	}
	subs.sort((a, b) => a[0] - b[0]);
	let i = 0;
	function sub(r) {
		const [a, b, t] = r;
		const prefix = text.slice(i, a);
		i = b;
		return prefix + t;
	}
	const parts = subs.map(sub);
	return parts.join("") + text.slice(i);
}
function assertCheckTemplate(template) {
	const r = checkTemplate(template);
	if (r instanceof Error) throw r;
}
function checkTemplate(template) {
	const chalk$1 = new Chalk();
	const chalkTemplate = makeTemplate(chalk$1);
	const substitutions = {
		$col: "<col>",
		$contextFull: "<contextFull>",
		$contextLeft: "<contextLeft>",
		$contextRight: "<contextRight>",
		$filename: "<filename>",
		$padContext: "<padContext>",
		$padRowCol: "<padRowCol>",
		$row: "<row>",
		$suggestions: "<suggestions>",
		$text: "<text>",
		$uri: "<uri>",
		$quickFix: "<quickFix>",
		$message: "<message>",
		$messageColored: "<messageColored>"
	};
	try {
		const t = chalkTemplate(template);
		const result = substitute(t, substitutions);
		const problems = [...result.matchAll(/\$[a-z]+/gi)].map((m) => m[0]);
		if (problems.length) throw new Error(`Unresolved template variable${problems.length > 1 ? "s" : ""}: ${problems.map((v) => `'${v}'`).join(", ")}`);
		return true;
	} catch (e) {
		const msg = e instanceof Error ? e.message : `${e}`;
		return new ApplicationError(msg);
	}
}

//#endregion
//#region src/config/adjustConfig.ts
async function fileExists(url) {
	if (url.protocol !== "file:") return false;
	try {
		const stats = await promises.stat(url);
		return stats.isFile();
	} catch (e) {
		const err = toError(e);
		if (err.code === "ENOENT") return false;
		throw e;
	}
}
async function resolveImports(configFile, imports) {
	const fromConfigDir = new URL("./", configFile.url);
	const fromCurrentDir = toFileDirURL("./");
	const require = createRequire(fromConfigDir);
	function isPackageName(name$1) {
		try {
			require.resolve(name$1, { paths: [fileURLToPath(fromConfigDir)] });
			return true;
		} catch {
			return false;
		}
	}
	const _imports = [];
	for (const imp of imports) {
		const url = new URL(imp, fromCurrentDir);
		if (url.protocol !== "file:") {
			_imports.push(imp);
			continue;
		}
		if (await fileExists(url)) {
			let rel = urlRelative(fromConfigDir, url);
			if (!(rel.startsWith("./") || rel.startsWith("../"))) rel = "./" + rel;
			_imports.push(rel);
			continue;
		}
		if (url.protocol !== "file:") {
			_imports.push(url.href);
			continue;
		}
		if (isPackageName(imp)) {
			_imports.push(imp);
			continue;
		}
		throw new Error(`Cannot resolve import: ${imp}`);
	}
	return _imports;
}
function addImportsToMutableConfigFile(configFile, resolvedImports, comment) {
	let importNode = configFile.getNode("import", []);
	if (importNode.type === "scalar") {
		configFile.setValue("import", [importNode.value]);
		importNode = configFile.getNode("import", []);
	}
	assert(isCfgArrayNode(importNode));
	const knownImports = new Set(importNode.value);
	for (const imp of resolvedImports) {
		if (knownImports.has(imp)) continue;
		importNode.push(imp);
	}
	if (comment) configFile.setComment("import", comment);
}
async function addImportsToConfigFile(configFile, imports, comment) {
	const resolvedImports = await resolveImports(configFile, imports);
	if (configFile instanceof MutableCSpellConfigFile) return addImportsToMutableConfigFile(configFile, resolvedImports, comment);
	const settings = configFile.settings;
	let importNode = settings.import;
	if (!Array.isArray(importNode)) {
		importNode = typeof importNode === "string" ? [importNode] : [];
		settings.import = importNode;
		if (comment) configFile.setComment("import", comment);
	}
	assert(Array.isArray(importNode));
	const knownImports = new Set(importNode);
	for (const imp of resolvedImports) {
		if (knownImports.has(imp)) continue;
		importNode.push(imp);
	}
}
function setConfigFieldValue(configFile, key, value, comment) {
	configFile.setValue(key, value);
	if (comment !== void 0) configFile.setComment(key, comment);
}
function addDictionariesToConfigFile(configFile, dictionaries, comment) {
	if (configFile instanceof MutableCSpellConfigFile) {
		const found = configFile.getValue("dictionaries");
		const dicts$1 = configFile.getNode("dictionaries", []);
		assert(isCfgArrayNode(dicts$1));
		const knownDicts$1 = new Set(dicts$1.value);
		for (const dict of dictionaries) if (!knownDicts$1.has(dict)) {
			dicts$1.push(dict);
			knownDicts$1.add(dict);
		}
		if (!found && comment) configFile.setComment("dictionaries", comment);
		return;
	}
	const settings = configFile.settings;
	const dicts = settings.dictionaries || [];
	const knownDicts = new Set(dicts);
	for (const dict of dictionaries) if (!knownDicts.has(dict)) {
		dicts.push(dict);
		knownDicts.add(dict);
	}
	setConfigFieldValue(configFile, "dictionaries", dicts, comment);
}

//#endregion
//#region src/config/config.ts
function applyValuesToConfigFile(config, settings, defaultValues, addComments) {
	const currentSettings = config.settings || {};
	for (const [k, entry] of Object.entries(defaultValues)) {
		const { value: defaultValue, comment } = entry;
		const key = k;
		const newValue = settings[key];
		const oldValue = currentSettings[key];
		const value = newValue ?? oldValue ?? defaultValue;
		if (newValue === void 0 && oldValue !== void 0 || value === void 0) continue;
		const useComment = addComments && oldValue === void 0 && comment || void 0;
		setConfigFieldValue(config, key, value, useComment);
	}
	return config;
}

//#endregion
//#region src/config/constants.ts
const defaultConfig = {
	$schema: {
		value: void 0,
		comment: " The schema for the configuration file."
	},
	version: {
		value: "0.2",
		comment: " The version of the configuration file format."
	},
	name: {
		value: void 0,
		comment: " The name of the configuration. Use for display purposes only."
	},
	description: {
		value: void 0,
		comment: " A description of the configuration."
	},
	language: {
		value: "en",
		comment: " The locale to use when spell checking. (e.g., en, en-GB, de-DE"
	},
	import: {
		value: void 0,
		comment: " Configuration or packages to import."
	},
	dictionaryDefinitions: {
		value: void 0,
		comment: " Define user dictionaries."
	},
	dictionaries: {
		value: void 0,
		comment: " Enable the dictionaries."
	},
	ignorePaths: {
		value: void 0,
		comment: " Glob patterns of files to be skipped."
	},
	files: {
		value: void 0,
		comment: " Glob patterns of files to be included."
	},
	words: {
		value: void 0,
		comment: " Words to be considered correct."
	},
	ignoreWords: {
		value: void 0,
		comment: " Words to be ignored."
	},
	flagWords: {
		value: void 0,
		comment: " Words to be flagged as incorrect."
	},
	overrides: {
		value: void 0,
		comment: " Set configuration based upon file globs."
	},
	languageSettings: {
		value: void 0,
		comment: " Define language specific settings."
	},
	enabledFileTypes: {
		value: void 0,
		comment: " Enable for specific file types."
	},
	caseSensitive: {
		value: void 0,
		comment: " Enable case sensitive spell checking."
	},
	patterns: {
		value: void 0,
		comment: " Regular expression patterns."
	},
	ignoreRegExpList: {
		value: void 0,
		comment: " Regular expressions / patterns of text to be ignored."
	},
	includeRegExpList: {
		value: void 0,
		comment: " Regular expressions / patterns of text to be included."
	}
};

//#endregion
//#region src/config/configInit.ts
const schemaRef = cspellConfigFileSchema;
const defaultConfigJson = `\
{
}
`;
const defaultConfigYaml = `
`;
async function configInit(options) {
	const rw = createReaderWriter();
	const url = determineFileNameURL(options);
	const configFile = await createConfigFile(rw, url, options);
	await applyOptionsToConfigFile(configFile, options);
	await fs.mkdir(new URL("./", configFile.url), { recursive: true });
	if (options.stdout) console.stdoutChannel.write(rw.serialize(configFile));
	else await rw.writeConfig(configFile);
}
async function applyOptionsToConfigFile(configFile, options) {
	const settings = {};
	const addComments = options.comments || options.comments === void 0 && !options.removeComments && !configFile.url.pathname.endsWith(".json");
	if (options.comments === false) configFile.removeAllComments();
	if (options.schema ?? true) configFile.setSchema(schemaRef);
	if (options.locale) settings.language = options.locale;
	applyValuesToConfigFile(configFile, settings, defaultConfig, addComments);
	if (options.import) await addImportsToConfigFile(configFile, options.import, addComments && defaultConfig.import?.comment || void 0);
	if (options.dictionary) addDictionariesToConfigFile(configFile, options.dictionary, addComments && defaultConfig.dictionaries?.comment || void 0);
	return configFile;
}
function determineFileNameURL(options) {
	if (options.config) return toFileURL(options.config);
	const defaultFileName = determineDefaultFileName(options);
	const outputUrl = toFileURL(options.output || defaultFileName);
	const path$2 = outputUrl.pathname;
	if (path$2.endsWith(".json") || path$2.endsWith(".jsonc") || path$2.endsWith(".yaml") || path$2.endsWith(".yml")) return outputUrl;
	if (/\.{m,c}?{j,t}s$/.test(path$2)) throw new Error(`Unsupported file extension: ${path$2}`);
	return new URL(defaultFileName, toFileDirURL(outputUrl));
}
function determineDefaultFileName(options) {
	switch (options.format || "yaml") {
		case "json": return "cspell.json";
		case "jsonc": return "cspell.jsonc";
		case "yaml": return "cspell.config.yaml";
		case "yml": return "cspell.config.yml";
	}
	throw new Error(`Unsupported format: ${options.format}`);
}
function getDefaultContent(options) {
	switch (options.format) {
		case void 0:
		case "yaml": return defaultConfigYaml;
		case "json":
		case "jsonc": return defaultConfigJson;
		default: throw new Error(`Unsupported format: ${options.format}`);
	}
}
async function createConfigFile(rw, url, options) {
	if (url.pathname.endsWith("package.json")) return rw.readConfig(url);
	const content = await fs.readFile(url, "utf8").catch(() => getDefaultContent(options));
	return rw.parse({
		url,
		content
	});
}

//#endregion
//#region src/featureFlags/featureFlags.ts
function getFeatureFlags() {
	return getSystemFeatureFlags();
}
function parseFeatureFlags(flags, featureFlags = getFeatureFlags()) {
	if (!flags) return featureFlags;
	const flagsKvP = flags.map((f) => f.split(":", 2));
	for (const flag of flagsKvP) {
		const [name$1, value] = flag;
		try {
			featureFlags.setFlag(name$1, value);
		} catch {
			console.warn(`Unknown flag: "${name$1}"`);
		}
	}
	return featureFlags;
}

//#endregion
//#region src/environment.ts
const environmentKeys = {
	CSPELL_ENABLE_DICTIONARY_LOGGING: "CSPELL_ENABLE_DICTIONARY_LOGGING",
	CSPELL_ENABLE_DICTIONARY_LOG_FILE: "CSPELL_ENABLE_DICTIONARY_LOG_FILE",
	CSPELL_ENABLE_DICTIONARY_LOG_FIELDS: "CSPELL_ENABLE_DICTIONARY_LOG_FIELDS",
	CSPELL_GLOB_ROOT: "CSPELL_GLOB_ROOT",
	CSPELL_CONFIG_PATH: "CSPELL_CONFIG_PATH",
	CSPELL_DEFAULT_CONFIG_PATH: "CSPELL_DEFAULT_CONFIG_PATH"
};
function setEnvironmentVariable(key, value) {
	process.env[key] = value;
}
function getEnvironmentVariable(key) {
	return process.env[key];
}
function truthy(value) {
	switch (value?.toLowerCase().trim()) {
		case "t":
		case "true":
		case "on":
		case "yes":
		case "1": return true;
	}
	return false;
}

//#endregion
//#region src/dirname.ts
let _dirname;
try {
	if (typeof import.meta.url !== "string") throw new Error("assert");
	_dirname = fileURLToPath(new URL(".", import.meta.url));
} catch {
	_dirname = __dirname;
}
const pkgDir = _dirname;

//#endregion
//#region src/pkgInfo.ts
const name = "cspell";
const version$1 = "9.2.1";
const engines = { node: ">=20" };
const npmPackage = {
	name,
	version: version$1,
	engines
};

//#endregion
//#region src/util/async.ts
const asyncMap = operators.opMapAsync;
const asyncFilter = operators.opFilterAsync;
const asyncAwait = operators.opAwaitAsync;
const asyncFlatten = operators.opFlattenAsync;

//#endregion
//#region src/util/constants.ts
const UTF8 = "utf8";
const STDIN = "stdin";
const STDINProtocol = "stdin:";
const STDINUrlPrefix = "stdin://";
const FileUrlPrefix = "file://";
const FileUrlAbsPrefix = "file:///";

//#endregion
//#region src/util/glob.ts
const defaultExcludeGlobs = ["node_modules/**"];
/**
*
* @param pattern - glob patterns and NOT file paths. It can be a file path turned into a glob.
* @param options - search options.
*/
async function globP(pattern, options) {
	const cwd = options?.root || options?.cwd || process.cwd();
	const ignoreRaw = typeof options?.ignore === "string" ? [options.ignore] : options?.ignore;
	const ignore = ignoreRaw?.filter((g) => !g.startsWith("../"));
	const onlyFiles = options?.nodir;
	const dot = options?.dot;
	const patterns = typeof pattern === "string" ? [pattern] : pattern;
	const useOptions = clean({
		cwd,
		onlyFiles,
		dot,
		ignore,
		absolute: true,
		followSymbolicLinks: false,
		expandDirectories: false
	});
	const compare$1 = new Intl.Collator("en").compare;
	const absolutePaths = (await glob$1(patterns, useOptions)).sort(compare$1);
	const relativePaths = absolutePaths.map((absFilename) => path$1.relative(cwd, absFilename));
	return relativePaths;
}
function calcGlobs(commandLineExclude) {
	const globs = new Set((commandLineExclude || []).flatMap((glob$2) => glob$2.split(/(?<!\\)\s+/g)).map((g) => g.replaceAll("\\ ", " ")));
	const commandLineExcludes = {
		globs: [...globs],
		source: "arguments"
	};
	const defaultExcludes = {
		globs: defaultExcludeGlobs,
		source: "default"
	};
	return commandLineExcludes.globs.length ? commandLineExcludes : defaultExcludes;
}
function extractPatterns(globs) {
	const r = globs.reduce((info, g) => {
		const source = g.source;
		const patterns = g.matcher.patternsNormalizedToRoot;
		return [...info, ...patterns.map((glob$2) => ({
			glob: glob$2,
			source
		}))];
	}, []);
	return r;
}
function calcExcludeGlobInfo(root, commandLineExclude) {
	commandLineExclude = typeof commandLineExclude === "string" ? [commandLineExclude] : commandLineExclude;
	const choice = calcGlobs(commandLineExclude);
	const matcher = new GlobMatcher(choice.globs, {
		root,
		dot: true
	});
	return [{
		matcher,
		source: choice.source
	}];
}
/**
* Build GlobMatcher from command line or config file globs.
* @param globs Glob patterns or file paths
* @param root - directory to use as the root
*/
function buildGlobMatcher(globs, root, isExclude) {
	const withRoots = globs.map((g) => {
		const source = typeof g === "string" ? "command line" : void 0;
		return {
			source,
			...fileOrGlobToGlob(g, root)
		};
	});
	return new GlobMatcher(withRoots, {
		root,
		mode: isExclude ? "exclude" : "include"
	});
}
function extractGlobsFromMatcher(globMatcher) {
	return globMatcher.patternsNormalizedToRoot.map((g) => g.glob);
}
function normalizeGlobsToRoot(globs, root, isExclude) {
	const urls = globs.filter((g) => typeof g === "string" && isPossibleUrlRegExp.test(g));
	const onlyGlobs = globs.filter((g) => typeof g !== "string" || !isPossibleUrlRegExp.test(g));
	return [urls, extractGlobsFromMatcher(buildGlobMatcher(onlyGlobs, root, isExclude))].flat();
}
const isPossibleGlobRegExp = /[()*?[{}]/;
const isPossibleUrlRegExp = /^[\d_a-z-]{3,}:\/\//;
/**
* If a 'glob' is a path to a directory, then append `**` so that
* directory searches work.
* @param glob - a glob, file, or directory
* @param root - root to use.
* @returns `**` is appended directories.
*/
async function adjustPossibleDirectory(glob$2, root) {
	const g = typeof glob$2 === "string" ? {
		glob: glob$2,
		root
	} : {
		glob: glob$2.glob,
		root: glob$2.root ?? root
	};
	if (isPossibleGlobRegExp.test(g.glob)) return glob$2;
	if (isPossibleUrlRegExp.test(g.glob)) return glob$2;
	const dirPath = path$1.resolve(g.root, g.glob);
	try {
		const stat$1 = await promises.stat(dirPath);
		if (stat$1.isDirectory()) {
			const useGlob = posix.join(posixPath(g.glob), "**");
			return typeof glob$2 === "string" ? useGlob : {
				...glob$2,
				glob: useGlob
			};
		}
	} catch {
		return glob$2;
	}
	return glob$2;
}
function posixPath(p) {
	return path$1.sep === "\\" ? p.replaceAll("\\", "/") : p;
}
async function normalizeFileOrGlobsToRoot(globs, root) {
	const adjustedGlobs = await Promise.all(globs.map((g) => adjustPossibleDirectory(g, root)));
	return normalizeGlobsToRoot(adjustedGlobs, root, false);
}
function glob$1(patterns, options) {
	patterns = typeof patterns === "string" ? workaroundPicomatchBug(patterns) : patterns.map((g) => workaroundPicomatchBug(g));
	return glob(patterns, options);
}

//#endregion
//#region src/util/stdin.ts
function readStdin() {
	return readline.createInterface(process.stdin);
}

//#endregion
//#region src/util/stdinUrl.ts
function isStdinUrl(url) {
	if (url instanceof URL) return url.protocol === STDINProtocol;
	return url.startsWith(STDINProtocol);
}
/**
* Normalize and resolve a stdin url.
* @param url - stdin url to resolve.
* @param cwd - file path to resolve relative paths against.
* @returns
*/
function resolveStdinUrl(url, cwd) {
	assert(url.startsWith(STDINProtocol), `Expected url to start with ${STDINProtocol}`);
	const path$2 = decodeURIComponent(url).slice(STDINProtocol.length).replace(/^\/\//, "").replace(/^\/([a-z]:)/i, "$1");
	const fileUrl = toFileURL(path$2, cwd);
	return new URL(fileUrl.toString().replace(/^file:/, STDINProtocol) + (path$2 ? "" : "/"));
}

//#endregion
//#region src/util/fileHelper.ts
function fileInfoToDocument(fileInfo, languageId, locale) {
	const { filename, text } = fileInfo;
	languageId = languageId || void 0;
	locale = locale || void 0;
	const uri = filenameToUrl(filename);
	if (uri.href.startsWith(STDINProtocol)) return clean({
		uri: uri.href,
		text,
		languageId,
		locale
	});
	return fileToDocument(uri.href, text, languageId, locale);
}
function filenameToUrl(filename, cwd = ".") {
	if (filename instanceof URL) return filename;
	const cwdURL = toFileDirURL(cwd);
	if (filename === STDIN) return new URL("stdin:///");
	if (isStdinUrl(filename)) return new URL(resolveStdinUrl(filename, cwd));
	return toFileURL(filename, cwdURL);
}
function filenameToUri(filename, cwd) {
	return toURL(filenameToUrl(filename, cwd));
}
function isBinaryFile$1(filename, cwd) {
	const uri = filenameToUri(filename, cwd);
	if (uri.protocol.startsWith("stdin")) return false;
	return isBinaryFile(uri);
}
function resolveFilenameToUrl(filename, cwd) {
	if (filename instanceof URL) return filename;
	if (filename === STDIN) return new URL(STDINUrlPrefix);
	if (filename.startsWith(FileUrlAbsPrefix)) return new URL(filename);
	const cwdUrl = toFileDirURL(cwd || process.cwd());
	if (filename.startsWith(FileUrlPrefix)) return new URL(filename.slice(FileUrlPrefix.length), cwdUrl);
	if (isStdinUrl(filename)) return resolveStdinUrl(filename, cwdUrl);
	return toFileURL(filename, cwdUrl);
}
function resolveFilename(filename, cwd) {
	return toFilePathOrHref(resolveFilenameToUrl(filename, cwd));
}
function readFileInfo(filename, encoding = UTF8, handleNotFound = false) {
	filename = resolveFilename(filename);
	const pText = filename.startsWith(STDINProtocol) ? streamConsumers.text(process.stdin) : readFileText(filename, encoding);
	return pText.then((text) => ({
		text,
		filename
	}), (e) => {
		const error = toError(e);
		return handleNotFound && error.code === "EISDIR" ? Promise.resolve({
			text: "",
			filename,
			errorCode: error.code
		}) : handleNotFound && error.code === "ENOENT" ? Promise.resolve({
			text: "",
			filename,
			errorCode: error.code
		}) : Promise.reject(new IOError(`Error reading file: "${filename}"`, error));
	});
}
function readFile(filename, encoding = UTF8) {
	return readFileInfo(filename, encoding).then((info) => info.text);
}
/**
* Looks for matching glob patterns or stdin
* @param globPatterns patterns or stdin
*/
async function findFiles(globPatterns, options) {
	const stdin = [];
	const globPats = globPatterns.filter((filename) => !isStdin(filename) && !filename.startsWith(FileUrlPrefix) ? true : (stdin.push(filename), false));
	const globResults = globPats.length ? await globP(globPats, options) : [];
	const cwd = options.cwd || process.cwd();
	return [...stdin, ...globResults].map((filename) => resolveFilename(filename, cwd));
}
const resolveFilenames = asyncMap(resolveFilename);
/**
* Read
* @param listFiles - array of file paths to read that will contain a list of files. Paths contained in each
*   file will be resolved relative to the containing file.
* @returns - a list of files to be processed.
*/
function readFileListFiles(listFiles) {
	let useStdin = false;
	const files = listFiles.filter((file) => {
		const isStdin$1 = file === "stdin";
		useStdin = useStdin || isStdin$1;
		return !isStdin$1;
	});
	const found = asyncPipe(files, asyncMap((file) => readFileListFile(file)), asyncAwait(), asyncFlatten());
	const stdin = useStdin ? readStdin() : [];
	return asyncPipe(mergeAsyncIterables(found, stdin), resolveFilenames);
}
/**
* Read a `listFile` and return the containing file paths resolved relative to the `listFile`.
* @param listFiles - array of file paths to read that will contain a list of files. Paths contained in each
*   file will be resolved relative to the containing file.
* @returns - a list of files to be processed.
*/
async function readFileListFile(listFile) {
	try {
		const relTo = path$1.resolve(path$1.dirname(listFile));
		const content = await readFile(listFile);
		const lines = content.split("\n").map((a) => a.trim()).filter((a) => !!a).map((file) => path$1.resolve(relTo, file));
		return lines;
	} catch (err) {
		throw toApplicationError(err, `Error reading file list from: "${listFile}"`);
	}
}
function isStdin(filename) {
	return filename === STDIN || isStdinUrl(filename);
}
async function isFile(filename) {
	if (isStdin(filename)) return true;
	try {
		const stat$1 = await promises.stat(filename);
		return stat$1.isFile();
	} catch {
		return false;
	}
}
async function isDir(filename) {
	try {
		const stat$1 = await promises.stat(filename);
		return stat$1.isDirectory();
	} catch {
		return false;
	}
}
function isNotDir(filename) {
	return isDir(filename).then((a) => !a);
}
function relativeToCwd(filename, cwd = process.cwd()) {
	const urlCwd = toFileDirURL(cwd);
	const url = toFileURL(filename, urlCwd);
	const rel = urlRelative(urlCwd, url);
	if (rel.startsWith("..")) return toFilePathOrHref(url);
	return rel;
}

//#endregion
//#region src/util/cache/file-entry-cache/flatCache.ts
var FlatCache = class {
	#cache;
	constructor(cacheFilename) {
		this.cacheFilename = cacheFilename;
		this.#cache = /* @__PURE__ */ new Map();
	}
	keys() {
		return this.#cache.keys();
	}
	set(key, value) {
		this.#cache.set(key, value);
		return this;
	}
	removeKey(key) {
		this.#cache.delete(key);
	}
	get(key) {
		return this.#cache.get(key);
	}
	async load(ifFound = true) {
		this.#cache.clear();
		try {
			const content = await fs.readFile(this.cacheFilename, "utf8");
			this.#cache = new Map(Object.entries(parse(content)));
		} catch (error) {
			if (!ifFound) throw error;
		}
		return this;
	}
	async save() {
		const dir = new URL(".", this.cacheFilename);
		await fs.mkdir(dir, { recursive: true });
		const content = stringify(Object.fromEntries(this.#cache.entries()));
		await fs.writeFile(this.cacheFilename, content, "utf8");
	}
	/**
	* Clear the cache and remove the cache file from disk.
	*/
	async destroy() {
		this.#cache.clear();
		try {
			await fs.unlink(this.cacheFilename);
		} catch {}
	}
};
/**
*
* @param cachefile - The location of the cache file.
* @returns
*/
function loadCacheFile(cachefile) {
	const cache = new FlatCache(cachefile);
	return cache.load();
}

//#endregion
//#region src/util/cache/file-entry-cache/file-entry-cache.ts
async function createFromFile$1(cacheFileUrl, useChecksum, currentWorkingDir) {
	const cache = await loadCacheFile(cacheFileUrl);
	const fec = new ImplFileEntryCache(cache, useChecksum ?? false, currentWorkingDir);
	await fec.removeNotFoundFiles();
	return fec;
}
var ImplFileEntryCache = class {
	cache;
	useChecksum;
	#normalizedEntries = /* @__PURE__ */ new Map();
	/**
	* To enable relative paths as the key with current working directory
	*/
	currentWorkingDir;
	constructor(cache, useChecksum, currentWorkingDir) {
		this.cache = cache;
		this.useChecksum = useChecksum || false;
		this.currentWorkingDir = currentWorkingDir ? fileURLToPath(currentWorkingDir) : void 0;
	}
	async removeNotFoundFiles() {
		for (const fPath of this.cache.keys()) try {
			const filePath = this.resolveKeyToFile(fPath);
			await fs.stat(filePath);
		} catch (error) {
			if (isNodeError(error) && error.code === "ENOENT") this.cache.removeKey(fPath);
		}
	}
	/**
	* Given a buffer, calculate md5 hash of its content.
	* @param  buffer buffer to calculate hash on
	* @return content hash digest
	*/
	#getHash(buffer) {
		return crypto.createHash("md5").update(buffer).digest("hex");
	}
	async getFileDescriptor(file) {
		let fstat;
		try {
			fstat = await fs.stat(file);
		} catch (error) {
			this.#removeEntry(file);
			return {
				key: file,
				notFound: true,
				err: toError$1(error)
			};
		}
		if (this.useChecksum) return this.#getFileDescriptorUsingChecksum(file);
		return this.#getFileDescriptorUsingMtimeAndSize(file, fstat);
	}
	#getFileDescriptorUsingMtimeAndSize(file, fstat) {
		const key = this.#getFileKey(file);
		let meta = this.cache.get(key);
		const cacheExists = !!meta;
		const cSize = fstat.size;
		const cTime = fstat.mtime.getTime();
		let isDifferentDate;
		let isDifferentSize;
		if (meta) {
			isDifferentDate = cTime !== meta.mtime;
			isDifferentSize = cSize !== meta.size;
		} else meta = {
			size: cSize,
			mtime: cTime
		};
		const nEntry = {
			key,
			changed: !cacheExists || isDifferentDate || isDifferentSize,
			meta
		};
		this.#normalizedEntries.set(key, nEntry);
		return nEntry;
	}
	async #getFileDescriptorUsingChecksum(file) {
		const key = this.#getFileKey(file);
		let meta = this.cache.get(key);
		const cacheExists = !!meta;
		let contentBuffer;
		try {
			contentBuffer = await fs.readFile(file);
		} catch {
			contentBuffer = "";
		}
		let isDifferent = true;
		const hash = this.#getHash(contentBuffer);
		if (meta) isDifferent = hash !== meta.hash;
		else meta = { hash };
		const nEntry = {
			key,
			changed: !cacheExists || isDifferent,
			meta
		};
		this.#normalizedEntries.set(key, nEntry);
		return nEntry;
	}
	/**
	* Remove an entry from the file-entry-cache. Useful to force the file to still be considered
	* modified the next time the process is run
	*/
	#removeEntry(file) {
		const key = this.#getFileKey(file);
		this.#normalizedEntries.delete(key);
		this.cache.removeKey(key);
	}
	/**
	* Deletes the cache file from the disk and clears the memory cache
	*/
	async destroy() {
		this.#normalizedEntries.clear();
		await this.cache.destroy();
	}
	async #getMetaForFileUsingCheckSum(cacheEntry) {
		const filePath = this.resolveKeyToFile(cacheEntry.key);
		const contentBuffer = await fs.readFile(filePath);
		const hash = this.#getHash(contentBuffer);
		const meta = {
			...cacheEntry.meta,
			hash
		};
		delete meta.size;
		delete meta.mtime;
		return meta;
	}
	async #getMetaForFileUsingMtimeAndSize(cacheEntry) {
		const filePath = this.resolveKeyToFile(cacheEntry.key);
		const stat$1 = await fs.stat(filePath);
		const meta = {
			...cacheEntry.meta,
			size: stat$1.size,
			mtime: stat$1.mtime.getTime()
		};
		delete meta.hash;
		return meta;
	}
	/**
	* Sync the files and persist them to the cache
	*/
	async reconcile() {
		await this.removeNotFoundFiles();
		for (const [entryKey, cacheEntry] of this.#normalizedEntries.entries()) try {
			const meta = this.useChecksum ? await this.#getMetaForFileUsingCheckSum(cacheEntry) : await this.#getMetaForFileUsingMtimeAndSize(cacheEntry);
			this.cache.set(entryKey, meta);
		} catch (error) {
			if (!isNodeError(error) || error.code !== "ENOENT") throw error;
		}
		this.cache.save();
	}
	resolveKeyToFile(entryKey) {
		if (this.currentWorkingDir) return path.resolve(this.currentWorkingDir, entryKey);
		return entryKey;
	}
	#getFileKey(file) {
		if (this.currentWorkingDir && path.isAbsolute(file)) return normalizePath$1(path.relative(this.currentWorkingDir, file));
		return normalizePath$1(file);
	}
};
function isNodeError(error) {
	return typeof error === "object" && error !== null && "code" in error;
}
function toError$1(error) {
	if (error instanceof Error) return error;
	if (typeof error === "string") return new Error(error);
	return new Error("Unknown error", { cause: error });
}
function normalizePath$1(filePath) {
	if (path.sep === "/") return filePath;
	return filePath.split(path.sep).join("/");
}

//#endregion
//#region src/util/cache/fileEntryCache.ts
function createFromFile(cacheFileUrl, useCheckSum, useRelative) {
	return createFromFile$1(cacheFileUrl, useCheckSum, useRelative ? new URL("./", cacheFileUrl) : void 0);
}

//#endregion
//#region src/util/cache/ObjectCollection.ts
const compare = Intl.Collator().compare;
var ShallowObjectCollection = class {
	tree = {};
	get(v) {
		if (typeof v !== "object" || v === null) return v;
		const keys = Object.entries(v).filter((entry) => entry[1] !== void 0).sort((a, b) => compare(a[0], b[0]));
		let t = this.tree;
		for (const [key, obj] of keys) {
			if (!t.c) t.c = /* @__PURE__ */ new Map();
			const c0 = t.c.get(key);
			const cc = c0 || /* @__PURE__ */ new Map();
			if (!c0) t.c.set(key, cc);
			const c1 = cc.get(obj);
			const ccc = c1 || {};
			if (!c1) cc.set(obj, ccc);
			t = ccc;
		}
		if (t.v) return t.v;
		t.v = v;
		return v;
	}
};

//#endregion
//#region src/util/cache/DiskCache.ts
const cacheDataKeys = {
	v: "v",
	r: "r",
	d: "d"
};
/**
* Meta Data Version is used to detect if the structure of the meta data has changed.
* This is used in combination with the Suffix and the version of CSpell.
*/
const META_DATA_BASE_VERSION = "1";
const META_DATA_VERSION_SUFFIX = "-" + META_DATA_BASE_VERSION + "-" + Object.keys(cacheDataKeys).join("|");
/**
* Caches cspell results on disk
*/
var DiskCache = class {
	cacheDir;
	dependencyCache = /* @__PURE__ */ new Map();
	dependencyCacheTree = {};
	objectCollection = new ShallowObjectCollection();
	ocCacheFileResult = new ShallowObjectCollection();
	version;
	constructor(cacheFileLocation, useCheckSum, cspellVersion, useUniversalCache, fileEntryCache) {
		this.cacheFileLocation = cacheFileLocation;
		this.useCheckSum = useCheckSum;
		this.cspellVersion = cspellVersion;
		this.useUniversalCache = useUniversalCache;
		this.fileEntryCache = fileEntryCache;
		this.cacheDir = fileURLToPath(new URL("./", cacheFileLocation));
		this.version = calcVersion(cspellVersion);
	}
	async getCachedLintResults(filename) {
		filename = normalizePath(filename);
		const fileDescriptor = await this.fileEntryCache.getFileDescriptor(filename);
		const meta = fileDescriptor.meta;
		const data = meta?.data;
		const result = data?.r;
		const versionMatches = this.version === data?.v;
		if (fileDescriptor.notFound || fileDescriptor.changed || !meta || !result || !versionMatches || !await this.checkDependencies(data.d)) return void 0;
		const dd = { ...data };
		if (dd.d) dd.d = setTreeEntry(this.dependencyCacheTree, dd.d);
		dd.r = dd.r && this.normalizeResult(dd.r);
		meta.data = this.objectCollection.get(dd);
		const hasErrors = !!result && (result.errors > 0 || result.configErrors > 0 || result.issues.length > 0);
		const cached = true;
		const shouldReadFile = hasErrors;
		return {
			...result,
			elapsedTimeMs: void 0,
			fileInfo: shouldReadFile ? await readFileInfo(filename) : { filename },
			cached
		};
	}
	async setCachedLintResults({ fileInfo, elapsedTimeMs: _, cached: __,...result }, dependsUponFiles) {
		const fileDescriptor = await this.fileEntryCache.getFileDescriptor(fileInfo.filename);
		const meta = fileDescriptor.meta;
		if (fileDescriptor.notFound || !meta) return;
		const data = this.objectCollection.get({
			v: this.version,
			r: this.normalizeResult(result),
			d: await this.calcDependencyHashes(dependsUponFiles)
		});
		meta.data = data;
	}
	async reconcile() {
		await this.fileEntryCache.reconcile();
	}
	async reset() {
		await this.fileEntryCache.destroy();
		this.dependencyCache.clear();
		this.dependencyCacheTree = {};
		this.objectCollection = new ShallowObjectCollection();
		this.ocCacheFileResult = new ShallowObjectCollection();
	}
	normalizeResult(result) {
		const { issues, processed, errors, configErrors, reportIssueOptions,...rest } = result;
		if (!Object.keys(rest).length) return this.ocCacheFileResult.get(result);
		return this.ocCacheFileResult.get({
			issues,
			processed,
			errors,
			configErrors,
			reportIssueOptions
		});
	}
	async calcDependencyHashes(dependsUponFiles) {
		dependsUponFiles.sort();
		const c = getTreeEntry(this.dependencyCacheTree, dependsUponFiles);
		if (c?.d) return c.d;
		const dependencies = await Promise.all(dependsUponFiles.map((f) => this.getDependency(f)));
		return setTreeEntry(this.dependencyCacheTree, dependencies);
	}
	async checkDependency(dep) {
		const depFile = this.resolveFile(dep.f);
		const cDep = this.dependencyCache.get(depFile);
		if (cDep && compDep(dep, cDep)) return true;
		if (cDep) return false;
		const d = await this.getFileDep(depFile);
		if (compDep(dep, d)) {
			this.dependencyCache.set(depFile, dep);
			return true;
		}
		this.dependencyCache.set(depFile, d);
		return false;
	}
	async getDependency(file) {
		const dep = this.dependencyCache.get(file);
		if (dep) return dep;
		const d = await this.getFileDep(file);
		this.dependencyCache.set(file, d);
		return d;
	}
	async getFileDep(file) {
		if (isUrlLike(file)) {
			if (!file.startsWith("file://")) return getDependencyForUrl(file);
			file = toFilePathOrHref(file);
		}
		assert(isAbsolute(file), `Dependency must be absolute "${file}"`);
		const f = this.toRelFile(file);
		let h;
		try {
			const buffer = await fs.readFile(file);
			h = this.getHash(buffer);
		} catch {
			return { f };
		}
		return {
			f,
			h
		};
	}
	async checkDependencies(dependencies) {
		if (!dependencies) return false;
		for (const dep of dependencies) if (!await this.checkDependency(dep)) return false;
		return true;
	}
	getHash(buffer) {
		return crypto.createHash("md5").update(buffer).digest("hex");
	}
	resolveFile(file) {
		if (isUrlLike(file)) return file;
		return normalizePath(resolve(this.cacheDir, file));
	}
	toRelFile(file) {
		return normalizePath(this.useUniversalCache ? relative(this.cacheDir, file) : file);
	}
};
async function getDependencyForUrl(remoteUrl) {
	const url = new URL(remoteUrl);
	try {
		const response = await fetch(url, { method: "HEAD" });
		const h = response.headers.get("etag") || response.headers.get("last-modified") || response.headers.get("content-length") || "";
		return {
			f: url.href,
			h: h ? h.trim() : ""
		};
	} catch {
		return {
			f: url.href,
			h: ""
		};
	}
}
async function createDiskCache(cacheFileLocation, useCheckSum, cspellVersion, useUniversalCache) {
	const fileEntryCache = await createFromFile(cacheFileLocation, useCheckSum, useUniversalCache);
	const cache = new DiskCache(cacheFileLocation, useCheckSum, cspellVersion, useUniversalCache, fileEntryCache);
	return cache;
}
function getTreeEntry(tree, keys) {
	let r = tree;
	for (const k of keys) {
		r = r.c?.get(k);
		if (!r) return r;
	}
	return r;
}
function setTreeEntry(tree, deps, update = false) {
	let r = tree;
	for (const d$1 of deps) {
		const k = d$1.f;
		if (!r.c) r.c = /* @__PURE__ */ new Map();
		const cn = r.c.get(k);
		const n = cn ?? {};
		if (!cn) r.c.set(k, n);
		r = n;
	}
	let d = r.d;
	if (!d || r.d && update) {
		r.d = deps;
		d = deps;
	}
	return d;
}
function compDep(a, b) {
	return a.f === b.f && a.h === b.h;
}
function calcVersion(version$2) {
	return version$2 + META_DATA_VERSION_SUFFIX;
}
function normalizePath(filePath) {
	if (sep === "/") return filePath;
	return filePath.split(sep).join("/");
}

//#endregion
//#region src/util/cache/DummyCache.ts
/**
* Dummy cache implementation that should be usd if caching option is disabled.
*/
var DummyCache = class {
	getCachedLintResults() {
		return Promise.resolve(void 0);
	}
	setCachedLintResults() {
		return Promise.resolve();
	}
	reconcile() {
		return Promise.resolve();
	}
	reset() {
		return Promise.resolve();
	}
};

//#endregion
//#region src/util/cache/createCache.ts
const DEFAULT_CACHE_LOCATION = ".cspellcache";
const versionSuffix = "";
/**
* Creates CSpellLintResultCache (disk cache if caching is enabled in config or dummy otherwise)
*/
async function createCache(options) {
	const { useCache, cacheLocation, cacheStrategy, reset } = options;
	const location = toFileURL(cacheLocation);
	const useChecksum = cacheStrategy === "content";
	const version$2 = normalizeVersion(options.version);
	const useUniversal = options.cacheFormat === "universal";
	const cache = useCache ? await createDiskCache(location, useChecksum, version$2, useUniversal) : new DummyCache();
	if (reset) await cache.reset();
	return cache;
}
async function calcCacheSettings(config, cacheOptions, root) {
	const cs = config.cache ?? {};
	const useCache = cacheOptions.cache ?? cs.useCache ?? false;
	const cacheLocation = await resolveCacheLocation(path.resolve(root, cacheOptions.cacheLocation ?? cs.cacheLocation ?? DEFAULT_CACHE_LOCATION));
	const cacheStrategy = cacheOptions.cacheStrategy ?? cs.cacheStrategy ?? "content";
	const cacheFormat = cacheOptions.cacheFormat ?? cs.cacheFormat ?? "universal";
	const optionals = {};
	if (cacheOptions.cacheReset) optionals.reset = true;
	return {
		...optionals,
		useCache,
		cacheLocation,
		cacheStrategy,
		version: cacheOptions.version,
		cacheFormat
	};
}
async function resolveCacheLocation(cacheLocation) {
	try {
		const s = await stat(cacheLocation);
		if (s.isFile()) return cacheLocation;
		return path.join(cacheLocation, DEFAULT_CACHE_LOCATION);
	} catch (err) {
		if (isErrorLike(err) && err.code === "ENOENT") return cacheLocation;
		throw err;
	}
}
/**
* Normalizes the version and return only `major.minor + versionSuffix`
* @param version The cspell semantic version.
*/
function normalizeVersion(version$2) {
	const parts = version$2.split(".").slice(0, 2);
	assert(parts.length === 2);
	return parts.join(".") + versionSuffix;
}

//#endregion
//#region src/util/configFileHelper.ts
async function readConfig(configFile, root, stopConfigSearchAt) {
	configFile ??= getEnvironmentVariable(environmentKeys.CSPELL_CONFIG_PATH);
	if (configFile) {
		const cfgFile = typeof configFile === "string" ? await readConfigHandleError(configFile) : configFile;
		return configFileToConfigInfo(cfgFile);
	}
	const config = await cspell.searchForConfig(root, { stopSearchAt: stopConfigSearchAt });
	const defaultConfigFile = getEnvironmentVariable(environmentKeys.CSPELL_DEFAULT_CONFIG_PATH);
	if (!config && defaultConfigFile) {
		const cfgFile = await readConfigFile(defaultConfigFile).catch(() => void 0);
		if (cfgFile) return configFileToConfigInfo(cfgFile);
	}
	return {
		source: config?.__importRef?.filename || "None found",
		config: config || {}
	};
}
async function configFileToConfigInfo(cfgFile) {
	const config = await cspell.resolveConfigFileImports(cfgFile);
	const source = toFilePathOrHref(cfgFile.url);
	return {
		source,
		config
	};
}
function readConfigFile(filename) {
	return cspell.readConfigFile(filename);
}
async function readConfigHandleError(filename) {
	try {
		return await readConfigFile(filename);
	} catch (e) {
		const settings = { __importRef: {
			filename: filename.toString(),
			error: e
		} };
		return {
			url: filenameToUrl(filename),
			settings
		};
	}
}

//#endregion
//#region src/util/extractContext.ts
function prefCharIndex(text, offset, count = 1) {
	if (offset - count < 0) return 0;
	for (; count > 0 && offset > 0; count--) {
		let code = text.charCodeAt(--offset) || 0;
		if (code === 65039) code = text.charCodeAt(--offset) || 0;
		offset -= (code & 64512) === 56320 ? 1 : 0;
	}
	return offset < 0 ? 0 : offset;
}
function nextCharIndex(text, offset, count = 1) {
	if (offset + count >= text.length) return text.length;
	for (; count > 0 && offset < text.length; count--) {
		const code = text.charCodeAt(offset++) || 0;
		offset += (code & 64512) === 55296 ? 1 : 0;
		if (text.charCodeAt(offset) === 65039) offset++;
	}
	return offset > text.length ? text.length : offset;
}
function lineContext(lineText, start, end, contextRange) {
	let left = prefCharIndex(lineText, start, contextRange);
	let right = nextCharIndex(lineText, end, contextRange);
	const isLetter = /^\p{L}$/u;
	const isMark = /^\p{M}$/u;
	for (let n = contextRange / 2; n > 0 && left > 0; n--, left--) {
		const c = lineText[left - 1];
		if (isMark.test(c)) {
			if (!isLetter.test(lineText[left - 2])) break;
			left--;
			continue;
		}
		if (!isLetter.test(lineText[left - 1])) break;
	}
	for (let n = contextRange / 2; n > 0 && right < lineText.length; n--, right++) {
		if (!isLetter.test(lineText[right])) break;
		if (isMark.test(lineText[right + 1])) right++;
	}
	left = left < 0 ? 0 : left;
	const t0 = lineText.slice(left, right);
	const tLeft = t0.trimStart();
	left = Math.min(left + t0.length - tLeft.length, start);
	const text = tLeft.trimEnd();
	const context = {
		text,
		offset: left
	};
	return context;
}
function extractContext(tdo, contextRange) {
	const { line, offset, text } = tdo;
	const start = offset - line.offset;
	const context = lineContext(line.text, start, start + text.length, contextRange);
	context.offset += line.offset;
	return context;
}

//#endregion
//#region src/util/prefetch.ts
function* prefetchIterable(iterable, size) {
	assert(size >= 0);
	const buffer = [];
	for (const value of iterable) {
		buffer.push(value);
		if (buffer.length >= size - 1) {
			const value$1 = buffer[0];
			buffer.shift();
			yield value$1;
		}
	}
	yield* buffer;
}

//#endregion
//#region src/util/reporters.ts
function filterFeatureIssues(features, issue, reportOptions) {
	if (issue.issueType === IssueType.directive) return features?.issueType && reportOptions?.validateDirectives || false;
	if (features?.unknownWords) return true;
	if (!reportOptions) return true;
	if (issue.isFlagged || !reportOptions.unknownWords || reportOptions.unknownWords === unknownWordsChoices.ReportAll) return true;
	if (issue.hasPreferredSuggestions && reportOptions.unknownWords !== unknownWordsChoices.ReportFlagged) return true;
	if (issue.hasSimpleSuggestions && reportOptions.unknownWords === unknownWordsChoices.ReportSimple) return true;
	return false;
}
function handleIssue(reporter, issue, reportOptions) {
	if (!reporter.issue) return;
	if (!filterFeatureIssues(reporter.features, issue, reportOptions)) return;
	if (!reporter.features?.contextGeneration && !issue.context) {
		issue = { ...issue };
		issue.context = issue.line;
	}
	return reporter.issue(issue, reportOptions);
}
/**
* Loads reporter modules configured in cspell config file
*/
async function loadReporters(reporters, defaultReporter, config) {
	async function loadReporter(reporterSettings) {
		if (reporterSettings === "default") return defaultReporter;
		if (!Array.isArray(reporterSettings)) reporterSettings = [reporterSettings];
		const [moduleName, settings] = reporterSettings;
		try {
			const { getReporter: getReporter$1 } = await dynamicImport(moduleName, [process.cwd(), pkgDir]);
			return getReporter$1(settings, config);
		} catch (e) {
			throw new ApplicationError(`Failed to load reporter ${moduleName}: ${toError(e).message}`);
		}
	}
	reporters = !reporters || !reporters.length ? ["default"] : [...reporters];
	const loadedReporters = await Promise.all(reporters.map(loadReporter));
	return loadedReporters.filter((v) => v !== void 0);
}
function finalizeReporter(reporter) {
	if (!reporter) return void 0;
	if (reporterIsFinalized(reporter)) return reporter;
	const final = {
		issue: (...params) => reporter.issue?.(...params),
		info: (...params) => reporter.info?.(...params),
		debug: (...params) => reporter.debug?.(...params),
		progress: (...params) => reporter.progress?.(...params),
		error: (...params) => reporter.error?.(...params),
		result: (...params) => reporter.result?.(...params),
		features: reporter.features
	};
	return final;
}
function reporterIsFinalized(reporter) {
	return !!reporter && reporter.features && typeof reporter.issue === "function" && typeof reporter.info === "function" && typeof reporter.debug === "function" && typeof reporter.error === "function" && typeof reporter.progress === "function" && typeof reporter.result === "function" || false;
}
const reportIssueOptionsKeyMap = {
	unknownWords: "unknownWords",
	validateDirectives: "validateDirectives",
	showContext: "showContext"
};
function setValue(options, key, value) {
	if (value !== void 0) options[key] = value;
}
function extractReporterIssueOptions(settings) {
	const src = settings;
	const options = {};
	for (const key in reportIssueOptionsKeyMap) {
		const k = key;
		setValue(options, k, src[k]);
	}
	return options;
}
function mergeReportIssueOptions(a, b) {
	const options = extractReporterIssueOptions(a);
	if (!b) return options;
	for (const key in reportIssueOptionsKeyMap) {
		const k = key;
		setValue(options, k, b[k]);
	}
	return options;
}
var LintReporter = class {
	#reporters = [];
	#config;
	#finalized = false;
	constructor(defaultReporter, config) {
		this.defaultReporter = defaultReporter;
		this.#config = config;
		if (defaultReporter) this.#reporters.push(finalizeReporter(defaultReporter));
	}
	get config() {
		return this.#config;
	}
	set config(config) {
		assert(!this.#finalized, "Cannot change the configuration of a finalized reporter");
		this.#config = config;
	}
	issue(issue, reportOptions) {
		for (const reporter of this.#reporters) handleIssue(reporter, issue, reportOptions);
	}
	info(...params) {
		for (const reporter of this.#reporters) reporter.info(...params);
	}
	debug(...params) {
		for (const reporter of this.#reporters) reporter.debug(...params);
	}
	error(...params) {
		for (const reporter of this.#reporters) reporter.error(...params);
	}
	progress(...params) {
		for (const reporter of this.#reporters) reporter.progress(...params);
	}
	async result(result) {
		await Promise.all(this.#reporters.map((reporter) => reporter.result?.(result)));
	}
	get features() {
		return {
			unknownWords: true,
			issueType: true
		};
	}
	async loadReportersAndFinalize(reporters) {
		assert(!this.#finalized, "Cannot change the configuration of a finalized reporter");
		const loaded = await loadReporters(reporters, this.defaultReporter, this.config);
		this.#reporters = [...new Set(loaded)].map((reporter) => finalizeReporter(reporter));
	}
	emitProgressBegin(filename, fileNum, fileCount) {
		this.progress({
			type: "ProgressFileBegin",
			fileNum,
			fileCount,
			filename
		});
	}
	emitProgressComplete(filename, fileNum, fileCount, result) {
		const filteredIssues = result.issues.filter((issue) => filterFeatureIssues({}, issue, result.reportIssueOptions));
		const numIssues = filteredIssues.length;
		for (const reporter of this.#reporters) {
			const progress = clean({
				type: "ProgressFileComplete",
				fileNum,
				fileCount,
				filename,
				elapsedTimeMs: result.elapsedTimeMs,
				processed: result.processed,
				numErrors: numIssues || result.errors,
				cached: result.cached,
				perf: result.perf,
				issues: reporter.features && result.issues,
				reportIssueOptions: reporter.features && result.reportIssueOptions
			});
			reporter.progress(progress);
		}
		result.issues.forEach((issue) => this.issue(issue, result.reportIssueOptions));
		return numIssues;
	}
};

//#endregion
//#region src/util/timer.ts
function getTimeMeasurer() {
	const timer = createPerfTimer("timer");
	return () => timer.elapsed;
}

//#endregion
//#region src/util/writeFile.ts
async function writeFileOrStream(filename, data) {
	switch (filename) {
		case "stdout":
			await writeStream(process.stdout, data);
			return;
		case "stderr":
			await writeStream(process.stderr, data);
			return;
		case "null": return;
	}
	return fs.writeFile(filename, data);
}
function writeStream(stream, data) {
	return new Promise((resolve$1, reject) => {
		stream.write(data, (err) => {
			if (err) reject(err);
			else resolve$1();
		});
	});
}

//#endregion
//#region src/lint/lint.ts
const version = npmPackage.version;
const BATCH_SIZE = 8;
const { opFilterAsync } = operators;
async function runLint(cfg) {
	const reporter = new LintReporter(cfg.reporter, cfg.options);
	const configErrors = /* @__PURE__ */ new Set();
	const timer = getTimeMeasurer();
	const logDictRequests = truthy(getEnvironmentVariable("CSPELL_ENABLE_DICTIONARY_LOGGING"));
	if (logDictRequests) _debug.cacheDictionaryEnableLogging(true);
	const lintResult = await run();
	if (logDictRequests) await writeDictionaryLog();
	await reporter.result(lintResult);
	const elapsed = timer();
	if (getFeatureFlags().getFlag("timer")) console.log(`Elapsed Time: ${elapsed.toFixed(2)}ms`);
	return lintResult;
	function prefetch(filename, configInfo, cache) {
		if (isBinaryFile$1(filename, cfg.root)) return {
			filename,
			result: Promise.resolve({ skip: true })
		};
		const reportIssueOptions = extractReporterIssueOptions(configInfo.config);
		async function fetch$1() {
			const getElapsedTimeMs = getTimeMeasurer();
			const cachedResult = await cache.getCachedLintResults(filename);
			if (cachedResult) {
				reporter.debug(`Filename: ${filename}, using cache`);
				const fileResult = {
					...cachedResult,
					elapsedTimeMs: getElapsedTimeMs()
				};
				return { fileResult };
			}
			const uri = filenameToUri(filename, cfg.root).href;
			const checkResult = await shouldCheckDocument({ uri }, {}, configInfo.config);
			if (!checkResult.shouldCheck) return { skip: true };
			const fileInfo = await readFileInfo(filename, void 0, true);
			return {
				fileInfo,
				reportIssueOptions
			};
		}
		const result = fetch$1();
		return {
			filename,
			result
		};
	}
	async function processFile(filename, configInfo, cache, prefetch$1) {
		if (prefetch$1?.fileResult) return prefetch$1.fileResult;
		const getElapsedTimeMs = getTimeMeasurer();
		const reportIssueOptions = prefetch$1?.reportIssueOptions;
		const cachedResult = await cache.getCachedLintResults(filename);
		if (cachedResult) {
			reporter.debug(`Filename: ${filename}, using cache`);
			return {
				...cachedResult,
				elapsedTimeMs: getElapsedTimeMs(),
				reportIssueOptions: {
					...cachedResult.reportIssueOptions,
					...reportIssueOptions
				}
			};
		}
		const result = {
			fileInfo: { filename },
			issues: [],
			processed: false,
			errors: 0,
			configErrors: 0,
			elapsedTimeMs: 0,
			reportIssueOptions
		};
		const fileInfo = prefetch$1?.fileInfo || await readFileInfo(filename, void 0, true);
		if (fileInfo.errorCode) {
			if (fileInfo.errorCode !== "EISDIR" && cfg.options.mustFindFiles) {
				const err = new LinterError(`File not found: "${filename}"`);
				reporter.error("Linter:", err);
				result.errors += 1;
			}
			return result;
		}
		const doc = fileInfoToDocument(fileInfo, cfg.options.languageId, cfg.locale);
		const { text } = fileInfo;
		result.fileInfo = fileInfo;
		let spellResult = {};
		reporter.info(`Checking: ${filename}, File type: ${doc.languageId ?? "auto"}, Language: ${doc.locale ?? "default"}`, MessageTypes.Info);
		try {
			const { showSuggestions: generateSuggestions, validateDirectives, skipValidation } = cfg.options;
			const numSuggestions = configInfo.config.numSuggestions ?? 5;
			const validateOptions = clean({
				generateSuggestions,
				numSuggestions,
				validateDirectives,
				skipValidation
			});
			const r = await spellCheckDocument(doc, validateOptions, configInfo.config);
			spellResult = r;
			result.processed = r.checked;
			result.perf = r.perf ? { ...r.perf } : void 0;
			result.issues = Text.calculateTextDocumentOffsets(doc.uri, text, r.issues).map(mapIssue);
		} catch (e) {
			reporter.error(`Failed to process "${filename}"`, toError(e));
			result.errors += 1;
		}
		result.elapsedTimeMs = getElapsedTimeMs();
		const config = spellResult.settingsUsed ?? {};
		result.reportIssueOptions = mergeReportIssueOptions(spellResult.settingsUsed || configInfo.config, reportIssueOptions);
		result.configErrors += await reportConfigurationErrors(config);
		const elapsed$1 = result.elapsedTimeMs;
		const dictionaries = config.dictionaries || [];
		reporter.info(`Checked: ${filename}, File type: ${config.languageId}, Language: ${config.language} ... Issues: ${result.issues.length} ${elapsed$1.toFixed(2)}ms`, MessageTypes.Info);
		reporter.info(`Config file Used: ${spellResult.localConfigFilepath || configInfo.source}`, MessageTypes.Info);
		reporter.info(`Dictionaries Used: ${dictionaries.join(", ")}`, MessageTypes.Info);
		if (cfg.options.debug) {
			const { id: _id, name: _name, __imports, __importRef,...cfg$1 } = config;
			const debugCfg = {
				filename,
				languageId: doc.languageId ?? cfg$1.languageId ?? "default",
				config: {
					...cfg$1,
					source: null
				},
				source: spellResult.localConfigFilepath
			};
			reporter.debug(JSON.stringify(debugCfg, void 0, 2));
		}
		const dep = calcDependencies(config);
		await cache.setCachedLintResults(result, dep.files);
		return result;
	}
	function mapIssue({ doc: _,...tdo }) {
		const context = cfg.showContext ? extractContext(tdo, cfg.showContext) : void 0;
		return clean({
			...tdo,
			context
		});
	}
	async function processFiles(files, configInfo, cacheSettings) {
		const fileCount = Array.isArray(files) ? files.length : void 0;
		const status = runResult();
		const cache = await createCache(cacheSettings);
		const failFast = cfg.options.failFast ?? configInfo.config.failFast ?? false;
		function* prefetchFiles(files$1) {
			const iter = prefetchIterable(pipe(files$1, opMap$1((filename) => prefetch(filename, configInfo, cache))), BATCH_SIZE);
			for (const v of iter) yield v;
		}
		async function* prefetchFilesAsync(files$1) {
			for await (const filename of files$1) yield prefetch(filename, configInfo, cache);
		}
		const emptyResult = {
			fileInfo: { filename: "" },
			issues: [],
			processed: false,
			errors: 0,
			configErrors: 0,
			elapsedTimeMs: 1,
			reportIssueOptions: void 0
		};
		async function processPrefetchFileResult(pf, index) {
			const { filename, result: pFetchResult } = pf;
			const getElapsedTimeMs = getTimeMeasurer();
			const fetchResult = await pFetchResult;
			reporter.emitProgressBegin(filename, index, fileCount ?? index);
			if (fetchResult?.skip) return {
				filename,
				fileNum: index,
				result: {
					...emptyResult,
					fileInfo: { filename },
					elapsedTimeMs: getElapsedTimeMs()
				}
			};
			const result = await processFile(filename, configInfo, cache, fetchResult);
			return {
				filename,
				fileNum: index,
				result
			};
		}
		async function* loadAndProcessFiles() {
			let i = 0;
			if (isAsyncIterable(files)) for await (const pf of prefetchFilesAsync(files)) yield processPrefetchFileResult(pf, ++i);
			else for (const pf of prefetchFiles(files)) {
				await pf.result;
				yield processPrefetchFileResult(pf, ++i);
			}
		}
		for await (const fileP of loadAndProcessFiles()) {
			const { filename, fileNum, result } = fileP;
			status.files += 1;
			status.cachedFiles = (status.cachedFiles || 0) + (result.cached ? 1 : 0);
			const numIssues = reporter.emitProgressComplete(filename, fileNum, fileCount ?? fileNum, result);
			if (numIssues || result.errors) {
				status.filesWithIssues.add(relativeToCwd(filename, cfg.root));
				status.issues += numIssues;
				status.errors += result.errors;
				if (failFast) return status;
			}
			status.errors += result.configErrors;
		}
		await cache.reconcile();
		return status;
	}
	function calcDependencies(config) {
		const { configFiles, dictionaryFiles } = extractDependencies(config);
		return { files: [...configFiles, ...dictionaryFiles] };
	}
	async function reportConfigurationErrors(config) {
		const errors = extractImportErrors(config);
		let count = 0;
		errors.forEach((ref) => {
			const key = ref.error.toString();
			if (configErrors.has(key)) return;
			configErrors.add(key);
			count += 1;
			reporter.error("Configuration", ref.error);
		});
		const dictCollection = await getDictionary(config);
		dictCollection.dictionaries.forEach((dict) => {
			const dictErrors = dict.getErrors?.() || [];
			const msg = `Dictionary Error with (${dict.name})`;
			dictErrors.forEach((error) => {
				const key = msg + error.toString();
				if (configErrors.has(key)) return;
				configErrors.add(key);
				count += 1;
				reporter.error(msg, error);
			});
		});
		return count;
	}
	function countConfigErrors(configInfo) {
		return reportConfigurationErrors(configInfo.config);
	}
	async function run() {
		if (cfg.options.root) setEnvironmentVariable(ENV_CSPELL_GLOB_ROOT, cfg.root);
		const configInfo = await readConfig(cfg.configFile, cfg.root, cfg.options.stopConfigSearchAt);
		if (cfg.options.defaultConfiguration !== void 0) configInfo.config.loadDefaultConfiguration = cfg.options.defaultConfiguration;
		configInfo.config = mergeSettings(configInfo.config, cfg.cspellSettingsFromCliOptions);
		const reporterConfig = clean({
			maxNumberOfProblems: configInfo.config.maxNumberOfProblems,
			maxDuplicateProblems: configInfo.config.maxDuplicateProblems,
			minWordLength: configInfo.config.minWordLength,
			...cfg.options,
			console
		});
		const reporters = cfg.options.reporter ?? configInfo.config.reporters;
		reporter.config = reporterConfig;
		await reporter.loadReportersAndFinalize(reporters);
		setLogger(getLoggerFromReporter(reporter));
		const globInfo = await determineGlobs(configInfo, cfg);
		const { fileGlobs, excludeGlobs } = globInfo;
		const hasFileLists = !!cfg.fileLists.length;
		if (!fileGlobs.length && !hasFileLists && !cfg.files?.length) return runResult();
		header(fileGlobs, excludeGlobs);
		checkGlobs(fileGlobs, reporter);
		reporter.info(`Config Files Found:\n    ${configInfo.source}\n`, MessageTypes.Info);
		const configErrors$1 = await countConfigErrors(configInfo);
		if (configErrors$1 && cfg.options.exitCode !== false && !cfg.options.continueOnError) return runResult({ errors: configErrors$1 });
		const { root } = cfg;
		try {
			const cacheSettings = await calcCacheSettings(configInfo.config, {
				...cfg.options,
				version
			}, root);
			const files = await determineFilesToCheck(configInfo, cfg, reporter, globInfo);
			const result = await processFiles(files, configInfo, cacheSettings);
			if (configErrors$1 && cfg.options.exitCode !== false) result.errors ||= configErrors$1;
			return result;
		} catch (e) {
			const err = toApplicationError(e);
			reporter.error("Linter", err);
			return runResult({ errors: 1 });
		}
	}
	function header(files, cliExcludes) {
		const formattedFiles = files.length > 100 ? [...files.slice(0, 100), "..."] : files;
		reporter.info(`
cspell;
Date: ${(/* @__PURE__ */ new Date()).toUTCString()}
Options:
    verbose:   ${yesNo(!!cfg.options.verbose)}
    config:    ${cfg.configFile || "default"}
    exclude:   ${cliExcludes.join("\n               ")}
    files:     ${formattedFiles}
    wordsOnly: ${yesNo(!!cfg.options.wordsOnly)}
    unique:    ${yesNo(!!cfg.options.unique)}
`, MessageTypes.Info);
	}
}
function checkGlobs(globs, reporter) {
	globs.filter((g) => g.startsWith("'") || g.endsWith("'")).map((glob$2) => chalk.yellow(glob$2)).forEach((glob$2) => reporter.error("Linter", new CheckFailed(`Glob starting or ending with ' (single quote) is not likely to match any files: ${glob$2}.`)));
}
async function determineGlobs(configInfo, cfg) {
	const useGitignore = cfg.options.gitignore ?? configInfo.config.useGitignore ?? false;
	const gitignoreRoots = cfg.options.gitignoreRoot ?? configInfo.config.gitignoreRoot;
	const gitIgnore = useGitignore ? await generateGitIgnore(gitignoreRoots) : void 0;
	const cliGlobs = cfg.fileGlobs;
	const allGlobs = cliGlobs.length && cliGlobs || cfg.options.filterFiles !== false && configInfo.config.files || [];
	const combinedGlobs = await normalizeFileOrGlobsToRoot(allGlobs, cfg.root);
	const cliExcludeGlobs = extractPatterns(cfg.excludes).map((p) => p.glob);
	const normalizedExcludes = normalizeGlobsToRoot(cliExcludeGlobs, cfg.root, true);
	const includeGlobs = combinedGlobs.filter((g) => !g.startsWith("!"));
	const excludeGlobs = [...combinedGlobs.filter((g) => g.startsWith("!")).map((g) => g.slice(1)), ...normalizedExcludes];
	const fileGlobs = includeGlobs;
	const appGlobs = {
		allGlobs,
		gitIgnore,
		fileGlobs,
		excludeGlobs,
		normalizedExcludes
	};
	return appGlobs;
}
async function determineFilesToCheck(configInfo, cfg, reporter, globInfo) {
	async function _determineFilesToCheck() {
		const { fileLists } = cfg;
		const hasFileLists = !!fileLists.length;
		const { allGlobs, gitIgnore, fileGlobs, excludeGlobs, normalizedExcludes } = globInfo;
		const { root } = cfg;
		const globsToExcludeRaw = [...configInfo.config.ignorePaths || [], ...excludeGlobs];
		const globsToExclude = globsToExcludeRaw.filter((g) => !globPattern(g).startsWith("!"));
		if (globsToExclude.length !== globsToExcludeRaw.length) {
			const globs = globsToExcludeRaw.map((g) => globPattern(g)).filter((g) => g.startsWith("!"));
			const msg = `Negative glob exclusions are not supported: ${globs.join(", ")}`;
			reporter.info(msg, MessageTypes.Warning);
		}
		const globMatcher = buildGlobMatcher(globsToExclude, root, true);
		const ignoreGlobs = extractGlobsFromMatcher(globMatcher);
		const globOptions = {
			root,
			cwd: root,
			ignore: [...ignoreGlobs, ...normalizedExcludes],
			nodir: true
		};
		const enableGlobDot = cfg.enableGlobDot ?? configInfo.config.enableGlobDot;
		if (enableGlobDot !== void 0) globOptions.dot = enableGlobDot;
		const opFilterExcludedFiles = opFilter(filterOutExcludedFilesFn(globMatcher));
		const includeFilter = createIncludeFileFilterFn(allGlobs, root, enableGlobDot);
		const rawCliFiles = cfg.files?.map((file) => resolveFilename(file, root)).filter(includeFilter);
		const cliFiles = cfg.options.mustFindFiles ? rawCliFiles : rawCliFiles && pipeAsync(rawCliFiles, opFilterAsync(isFile));
		const foundFiles = hasFileLists ? concatAsyncIterables(cliFiles, await useFileLists(fileLists, includeFilter)) : cliFiles || await findFiles(fileGlobs, globOptions);
		const filtered = gitIgnore ? await gitIgnore.filterOutIgnored(foundFiles) : foundFiles;
		const files = isAsyncIterable(filtered) ? pipeAsync(filtered, opFilterExcludedFiles) : [...pipe(filtered, opFilterExcludedFiles)];
		return files;
	}
	function isExcluded(filename, globMatcherExclude) {
		if (isBinaryFile(toFileURL(filename))) return true;
		const { root } = cfg;
		const absFilename = path$1.resolve(root, filename);
		const r = globMatcherExclude.matchEx(absFilename);
		if (r.matched) {
			const { glob: glob$2, source } = extractGlobSource(r.pattern);
			reporter.info(`Excluded File: ${path$1.relative(root, absFilename)}; Excluded by ${glob$2} from ${source}`, MessageTypes.Info);
		}
		return r.matched;
	}
	function filterOutExcludedFilesFn(globMatcherExclude) {
		const patterns = globMatcherExclude.patterns;
		const excludeInfo = patterns.map(extractGlobSource).map(({ glob: glob$2, source }) => `Glob: ${glob$2} from ${source}`).filter(uniqueFn());
		reporter.info(`Exclusion Globs: \n    ${excludeInfo.join("\n    ")}\n`, MessageTypes.Info);
		return (filename) => !isExcluded(filename, globMatcherExclude);
	}
	return _determineFilesToCheck();
}
function extractGlobSource(g) {
	const { glob: glob$2, rawGlob, source } = g;
	return {
		glob: rawGlob || glob$2,
		source
	};
}
function runResult(init = {}) {
	const { files = 0, filesWithIssues = /* @__PURE__ */ new Set(), issues = 0, errors = 0, cachedFiles = 0 } = init;
	return {
		files,
		filesWithIssues,
		issues,
		errors,
		cachedFiles
	};
}
function yesNo(value) {
	return value ? "Yes" : "No";
}
function getLoggerFromReporter(reporter) {
	const log = (...params) => {
		const msg = format(...params);
		reporter.info(msg, "Info");
	};
	const error = (...params) => {
		const msg = format(...params);
		const err = {
			message: "",
			name: "error",
			toString: () => ""
		};
		reporter.error(msg, err);
	};
	const warn = (...params) => {
		const msg = format(...params);
		reporter.info(msg, "Warning");
	};
	return {
		log,
		warn,
		error
	};
}
async function generateGitIgnore(roots) {
	const root = (typeof roots === "string" ? [roots].filter((r) => !!r) : roots) || [];
	if (!root?.length) {
		const cwd = process.cwd();
		const repo = await findRepoRoot(cwd) || cwd;
		root.push(repo);
	}
	return new GitIgnore(root?.map((p) => path$1.resolve(p)));
}
async function useFileLists(fileListFiles, filterFiles) {
	const files = readFileListFiles(fileListFiles);
	return pipeAsync(files, opFilter(filterFiles), opFilterAsync(isNotDir));
}
function createIncludeFileFilterFn(includeGlobPatterns, root, dot) {
	if (!includeGlobPatterns?.length) return () => true;
	const patterns = includeGlobPatterns.map((g) => g === "." ? "/**" : g);
	const options = {
		root,
		mode: "include"
	};
	if (dot !== void 0) options.dot = dot;
	const globMatcher = new GlobMatcher(patterns, options);
	return (file) => globMatcher.match(file);
}
async function* concatAsyncIterables(...iterables) {
	for (const iter of iterables) {
		if (!iter) continue;
		yield* iter;
	}
}
async function writeDictionaryLog() {
	const fieldsCsv = getEnvironmentVariable("CSPELL_ENABLE_DICTIONARY_LOG_FIELDS") || "time, word, value";
	const fields = fieldsCsv.split(",").map((f) => f.trim());
	const header = fields.join(", ") + "\n";
	const lines = _debug.cacheDictionaryGetLog().filter((d) => d.method === "has").map((d) => fields.map((f) => f in d ? `${d[f]}` : "").join(", "));
	const data = header + lines.join("\n") + "\n";
	const filename = getEnvironmentVariable("CSPELL_ENABLE_DICTIONARY_LOG_FILE") || "cspell-dictionary-log.csv";
	await writeFileOrStream(filename, data);
}
function globPattern(g) {
	return typeof g === "string" ? g : g.glob;
}
var LinterError = class extends Error {
	constructor(message) {
		super(message);
	}
	toString() {
		return this.message;
	}
};

//#endregion
//#region src/lint/LintRequest.ts
const defaultContextRange = 20;
var LintRequest = class {
	locale;
	configFile;
	excludes;
	root;
	showContext;
	enableGlobDot;
	fileLists;
	files;
	cspellSettingsFromCliOptions;
	constructor(fileGlobs, options, reporter) {
		this.fileGlobs = fileGlobs;
		this.options = options;
		this.reporter = reporter;
		this.root = path$1.resolve(options.root || process.cwd());
		this.configFile = options.config;
		this.excludes = calcExcludeGlobInfo(this.root, options.exclude);
		this.locale = options.locale ?? options.local ?? "";
		this.enableGlobDot = options.dot;
		this.showContext = Math.max(options.showContext === true ? defaultContextRange : options.showContext ? options.showContext : 0, 0);
		this.fileLists = (options.fileList ?? options.fileLists) || [];
		this.files = mergeFiles(options.file, options.files);
		const noConfigSearch = options.configSearch === false ? true : options.configSearch === true ? false : void 0;
		const dictionaries = [...(options.disableDictionary ?? []).map((d) => `!${d}`), ...(options.dictionary ?? []).map((d) => `!!${d}`)];
		const languageSettings = [{
			languageId: "*",
			locale: "*",
			dictionaries
		}];
		this.cspellSettingsFromCliOptions = {
			...noConfigSearch !== void 0 ? { noConfigSearch } : {},
			...extractUnknownWordsConfig(options),
			languageSettings
		};
	}
};
function mergeFiles(a, b) {
	const files = merge(a, b);
	if (!files) return void 0;
	return [...new Set(files.flatMap((a$1) => a$1.split("\n").map((a$2) => a$2.trim())).filter((a$1) => !!a$1))];
}
function merge(a, b) {
	if (!a) return b;
	if (!b) return a;
	return [...a, ...b];
}
function extractUnknownWordsConfig(options) {
	const config = {};
	if (!options.report) return config;
	switch (options.report) {
		case "all":
			config.unknownWords = unknownWordsChoices.ReportAll;
			break;
		case "simple":
			config.unknownWords = unknownWordsChoices.ReportSimple;
			break;
		case "typos":
			config.unknownWords = unknownWordsChoices.ReportCommonTypos;
			break;
		case "flagged":
			config.unknownWords = unknownWordsChoices.ReportFlagged;
			break;
	}
	return config;
}

//#endregion
//#region src/options.ts
const ReportChoicesAll = [
	"all",
	"simple",
	"typos",
	"flagged"
];
function fixLegacy(opts) {
	const { local,...rest } = opts;
	if (local && !rest.locale) rest.locale = local;
	return rest;
}

//#endregion
//#region src/repl/index.ts
function simpleRepl() {
	return new SimpleRepl();
}
var SimpleRepl = class {
	beforeEach;
	completer;
	_history;
	rl;
	constructor(prompt = "> ") {
		this.prompt = prompt;
		this._history = [];
		this.rl = readline.createInterface({
			input: process.stdin,
			output: process.stdout,
			prompt,
			history: this._history,
			historySize: 100,
			completer: (line) => this._completer(line)
		});
		this.rl.on("history", (h) => (this._history = h, void 0));
	}
	question(query) {
		return new Promise((resolve$1) => {
			this.rl.question(query, resolve$1);
		});
	}
	_completer(line) {
		if (this.completer) return this.completer(line);
		const hist = this._history.filter((h) => h.startsWith(line));
		return [hist, line];
	}
	get history() {
		return this._history;
	}
	[Symbol.asyncIterator]() {
		const next = () => {
			if (this.beforeEach) this.beforeEach();
			return this.question(this.prompt).then((value) => ({ value })).catch(() => ({
				done: true,
				value: void 0
			}));
		};
		return { next };
	}
};

//#endregion
//#region src/dictionaries/listDictionaries.ts
const inlineDictionaries = {
	"[words]": {
		name: "[words]",
		description: "List of words to be included in the spell check.",
		enabled: true
	},
	"[flagWords]": {
		name: "[flagWords]",
		description: "List of words to be flagged as incorrect.",
		enabled: true
	},
	"[ignoreWords]": {
		name: "[ignoreWords]",
		description: "List of words to be ignored in the spell check.",
		enabled: true
	},
	"[suggestWords]": {
		name: "[suggestWords]",
		description: "List of spelling suggestions for words.",
		enabled: true
	}
};
function splitList(list) {
	if (!list) return [];
	if (typeof list === "string") return list.split(",").map((s) => s.trim()).filter((s) => !!s);
	return list.flatMap((s) => splitList(s));
}
function extractDictionaryLocalesAndFileTypes(config) {
	const map = /* @__PURE__ */ new Map();
	function getDict(name$1) {
		const found = map.get(name$1);
		if (found) return found;
		const dict = {
			locales: /* @__PURE__ */ new Set(),
			fileTypes: /* @__PURE__ */ new Set()
		};
		map.set(name$1, dict);
		return dict;
	}
	const languageSettings = config.languageSettings || [];
	for (const lang of languageSettings) {
		const locales = splitList(lang.locale);
		const fileTypes = splitList(lang.languageId);
		const dicts = lang.dictionaries || [];
		for (const dictName of dicts) {
			const dict = getDict(dictName);
			for (const locale of locales) if (locale) dict.locales.add(locale);
			for (const fileType of fileTypes) if (fileType) dict.fileTypes.add(fileType);
		}
	}
	return map;
}
function extractInlineDictionaries(dict) {
	const iDict = dict;
	const inline = [];
	if (iDict.words?.length) inline.push("[words]");
	if (iDict.flagWords?.length) inline.push("[flagWords]");
	if (iDict.ignoreWords?.length) inline.push("[ignoreWords]");
	if (iDict.suggestWords?.length) inline.push("[suggestWords]");
	return inline.length ? inline : void 0;
}
function extractSpecialDictionaries(config) {
	const specialDictionaries = [];
	if (config.words?.length) specialDictionaries.push(inlineDictionaries["[words]"]);
	if (config.flagWords?.length) specialDictionaries.push(inlineDictionaries["[flagWords]"]);
	if (config.ignoreWords?.length) specialDictionaries.push(inlineDictionaries["[ignoreWords]"]);
	if (config.suggestWords?.length) specialDictionaries.push(inlineDictionaries["[suggestWords]"]);
	return specialDictionaries;
}
async function listDictionaries(options) {
	const configFile = await readConfig(options.config, void 0);
	const loadDefault = options.defaultConfiguration ?? configFile.config.loadDefaultConfiguration ?? true;
	const configBase = mergeSettings(await getDefaultSettings(loadDefault), await getGlobalSettingsAsync(), configFile.config);
	const useFileType = options.fileType === "text" ? "plaintext" : options.fileType;
	if (options.locale) configBase.language = options.locale;
	const config = combineTextAndLanguageSettings(configBase, "", useFileType || configBase.languageId || "plaintext");
	const dictionaryLocalesAndFileTypes = extractDictionaryLocalesAndFileTypes(config);
	const enabledDictionaries = new Set(config.dictionaries || []);
	function toListDictionariesResult(dict) {
		const inline = extractInlineDictionaries(dict);
		return {
			name: dict.name,
			description: dict.description,
			enabled: enabledDictionaries.has(dict.name),
			path: dict.path,
			inline,
			locales: [...dictionaryLocalesAndFileTypes.get(dict.name)?.locales || []].sort(),
			fileTypes: [...dictionaryLocalesAndFileTypes.get(dict.name)?.fileTypes || []].sort()
		};
	}
	function filterDicts(dict) {
		if (options.enabled === void 0) return true;
		return options.enabled === enabledDictionaries.has(dict.name);
	}
	const dictionaryDefinitions = (config.dictionaryDefinitions || []).filter(filterDicts);
	dictionaryDefinitions.sort((a, b) => a.name.localeCompare(b.name));
	const specialDicts = options.enabled !== false ? extractSpecialDictionaries(config) : [];
	return [...specialDicts, ...dictionaryDefinitions.map(toListDictionariesResult)];
}

//#endregion
//#region src/application.mts
function lint(fileGlobs, options, reporter) {
	options = fixLegacy(options);
	const unknownWordsConfig = extractUnknownWordsConfig(options);
	const useOptions = {
		...options,
		...unknownWordsConfig
	};
	const reporterOptions = {
		...useOptions,
		console
	};
	const cfg = new LintRequest(fileGlobs, useOptions, finalizeReporter(reporter) ?? getReporter({
		...useOptions,
		fileGlobs
	}, reporterOptions));
	return runLint(cfg);
}
async function* trace(words, options) {
	options = fixLegacy(options);
	const iWords = options.stdin ? toAsyncIterable(words, readStdin()) : words;
	const { languageId, locale, allowCompoundWords, ignoreCase } = options;
	const configFile = await readConfig(options.config, void 0);
	const loadDefault = options.defaultConfiguration ?? configFile.config.loadDefaultConfiguration ?? true;
	const additionalSettings = {};
	if (options.dictionary) additionalSettings.dictionaries = options.dictionary;
	const config = mergeSettings(await getDefaultSettings(loadDefault), await getGlobalSettingsAsync(), configFile.config, additionalSettings);
	yield* traceWordsAsync(iWords, config, clean({
		languageId,
		locale,
		ignoreCase,
		allowCompoundWords
	}));
}
async function checkText(filename, options) {
	options = fixLegacy(options);
	const fileInfo = await readFileInfo(filename);
	const { locale, languageId, validateDirectives } = options;
	const doc = fileInfoToDocument(fileInfo, languageId, locale);
	const checkOptions = {
		configFile: options.config,
		validateDirectives
	};
	const settingsFromCommandLine = clean({
		languageId,
		language: locale,
		loadDefaultConfiguration: options.defaultConfiguration
	});
	return checkTextDocument(doc, clean({ ...checkOptions }), settingsFromCommandLine);
}
async function* suggestions(words, options) {
	options = fixLegacy(options);
	const configFile = await readConfig(options.config, void 0);
	let timer;
	function tapStart() {
		timer = getTimeMeasurer();
	}
	function mapStart(v) {
		tapStart();
		return v;
	}
	function mapEnd(v) {
		const elapsedTimeMs = timer?.();
		return elapsedTimeMs ? {
			...v,
			elapsedTimeMs
		} : v;
	}
	const iWords = options.repl ? pipeAsync(toAsyncIterable(words, simpleRepl()), opTap(tapStart)) : options.useStdin ? pipeAsync(toAsyncIterable(words, readStdin()), opTap(tapStart)) : words.map(mapStart);
	try {
		const results = pipeAsync(suggestionsForWords(iWords, clean({ ...options }), configFile.config), opMap(mapEnd));
		yield* results;
	} catch (e) {
		if (!(e instanceof SuggestionError)) throw e;
		console.error(e.message);
		process.exitCode = 1;
	}
}
function createInit(options) {
	return configInit(options);
}
function registerApplicationFeatureFlags() {
	const ff = getFeatureFlags();
	const flags = [{
		name: "timer",
		description: "Display elapsed time for command."
	}];
	flags.forEach((flag) => ff.register(flag));
	return ff;
}
function parseApplicationFeatureFlags(flags) {
	const ff = registerApplicationFeatureFlags();
	return parseFeatureFlags(flags, ff);
}

//#endregion
export { ApplicationError, CheckFailed, DEFAULT_CACHE_LOCATION, IncludeExcludeFlag, ReportChoicesAll, checkText, console, createInit, getReporter, lint, listDictionaries, npmPackage, parseApplicationFeatureFlags, suggestions, trace };
//# sourceMappingURL=application-BZlf5spr.js.map